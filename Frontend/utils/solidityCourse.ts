export const solidityCourse = {
  id: "basics-of-solidity",
  title: "Basics of Solidity",
  description:
    "Learn the fundamentals of Solidity programming and smart contract development for blockchain applications.",
  level: "Beginner" as "Beginner",
  duration: "4 weeks",
  lessonCount: 7,
  tags: ["solidity", "basics"],
  registrations: 1,
  image: "/images/solidity-basics.png",
  lessons: [
    {
      id: "intro-to-solidity",
      title: "Introduction to Solidity & Smart Contracts",
      content:
        "# Lesson 1: Introduction to Solidity & Smart Contracts\n\nHey there, future blockchain developer! Welcome to the world of Solidity! If you've ever wondered, \"What exactly is a smart contract, and why is everyone talking about it?\"‚Äîyou're in the right place. Let's break it down without any complex jargon and have some fun along the way.\n\n---\n\n## What is Solidity?\n\nImagine you are writing a magic spell, but instead of controlling mythical creatures, your spell controls money, ownership, and agreements on the blockchain. Solidity is the language used to write these spells (smart contracts).\n\nIt's similar to JavaScript but with some extra features. With Solidity, you can create self-executing agreements that nobody can change or tamper with‚Äînot even you after deploying them.\n\n---\n\n## What are Smart Contracts?\n\nThink of a smart contract as a vending machine:\n- You put money in (send cryptocurrency).\n- You select your snack (trigger a function).\n- The vending machine checks if you inserted the correct amount (validates conditions).\n- If yes, it automatically drops your snack (executes the function).\n\nNo shopkeeper is needed. No middleman. Just instant execution based on clear rules written in Solidity.\n\n### Another way to think about it:\n- **Normal contracts** are written on paper and need lawyers to enforce them.\n- **Smart contracts** are written in code and enforce themselves automatically.\n\nBlockchain ensures nobody can cheat, because once a smart contract is deployed, it runs exactly as written.\n\n---\n\n## Use Cases of Smart Contracts\n\nNow that we know what smart contracts are, let's check out where they're used in real life:\n\n‚úÖ **Decentralized Finance (DeFi)** ‚Äì Borrow, lend, and trade crypto without banks.  \n‚úÖ **NFTs** ‚Äì Own unique digital art, music, or in-game items.  \n‚úÖ **Supply Chain** ‚Äì Track where products come from without trusting middlemen.  \n‚úÖ **Ticketing** ‚Äì Buy concert tickets that can't be counterfeited.  \n‚úÖ **Voting Systems** ‚Äì Fair elections without fraud.  \n\nSmart contracts remove middlemen and make processes more transparent. No trust issues, no hidden fees‚Äîjust pure automation.\n\n---\n\n## Writing a Simple \"Hello World\" Smart Contract\n\nNow, let's write our first Solidity program.\n\nIf you've coded before, you might remember that in most programming languages, the first thing we write is a \"Hello, World!\" program. It's like saying hello to the language.\n\n### Here‚Äôs what it looks like in Solidity:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract HelloWorld {\n    string public message = \"Hello, World!\";\n}\n```\n\n### Breaking it down:\n- `pragma solidity ^0.8.0;` ‚Üí Tells the compiler which Solidity version to use.\n- `contract HelloWorld {}` ‚Üí Defines a smart contract named \"HelloWorld\".\n- `string public message = \"Hello, World!\";` ‚Üí A public variable storing the message.\n\n### What this contract does:\n- It stores a \"Hello, World!\" message.\n- Since the variable is public, anyone can read it.\n\nSimple, right? You just wrote your first smart contract! üéâ\n\n---\n\n## Try It Yourself\n\nNow, head over to our **Solidity Code Editor** and type it in. Hit **Compile** and see if it works!\n\n‚úÖ **If it compiles successfully**, congrats! You've just taken your first step into blockchain development.  \n‚ùå **If there's an error**, don‚Äôt worry‚Äîour AI suggestions will help you fix it.  \n\n---\n\n## What's Next?\n\nIn the next lesson, we'll explore **Solidity‚Äôs syntax and data types**‚Äîit‚Äôs like learning the alphabet before writing full sentences. Stay curious and keep experimenting. See you in **Lesson 2!** üöÄ\n",
    },
    {
      id: "solidity-syntax",
      title: "Solidity Syntax and Data Types",
      content:
        '# Lesson 2: Solidity Syntax & Data Types\n\nWelcome back, blockchain developer!  \nNow that you\'ve said Hello, World! in Solidity, let‚Äôs break down the language itself‚Äîkind of like understanding the grammar of a new language before writing full stories.\n\nSolidity is simple, but it does have its own rules and structure. Let‚Äôs explore!\n\n## 1. Structure of a Solidity Smart Contract\n\nThink of a Solidity contract like a recipe.\n\nA recipe has:\n1. Title (Contract name)\n2. Ingredients (State variables)\n3. Instructions (Functions)\n\nHere\'s a basic Solidity contract skeleton:\n\n```solidity\n// Step 1: Declare the version\npragma solidity ^0.8.0;\n\n// Step 2: Define the contract\ncontract MyFirstContract {\n    \n    // Step 3: Declare variables\n    string public myMessage = "Hello, Solidity!";\n    \n    // Step 4: Write functions\n    function setMessage(string memory newMessage) public {\n        myMessage = newMessage;\n    }\n}\n```\n\n### Breakdown:\n- `pragma solidity ^0.8.0;` ‚Üí Solidity version (like saying ‚Äúwe‚Äôre using the latest English dictionary‚Äù).\n- `contract MyFirstContract {}` ‚Üí The blueprint of our smart contract.\n- `string public myMessage = "Hello, Solidity!";` ‚Üí A public state variable storing a message.\n- `function setMessage(string memory newMessage) public {}` ‚Üí A function to change the message.\n\nEasy, right? Now, let‚Äôs talk about data types‚Äîthe building blocks of Solidity!\n\n## 2. Solidity Data Types\n\nIn Solidity, we store and process data using different types. Think of them like different kinds of containers in a kitchen.\n\n### a) Numbers (uint & int)\n- `uint` (Unsigned Integer) ‚Äì Whole numbers that are only positive (like 0, 1, 2, 100).\n- `int` (Signed Integer) ‚Äì Whole numbers that can be both positive & negative (like -5, 0, 42).\n\n#### Example:\n```solidity\nuint256 public positiveNumber = 42;  // Stores 42\nint256 public negativeNumber = -42;  // Stores -42\n```\n\n### b) Strings (Words & Sentences)\n- `string` ‚Äì Stores text, like a note in a diary.\n\n#### Example:\n```solidity\nstring public name = "Solidity"; \n```\n\nWhy use `memory`?  \nWhen passing a string in a function, Solidity needs to know where to store it (temporarily or permanently). We‚Äôll cover this later.\n\n### c) Boolean (True/False)\n- `bool` ‚Äì Think of it as a light switch: ON (true) or OFF (false).\n\n#### Example:\n```solidity\nbool public isCodingFun = true;\n```\n\n### d) Address (Wallet Address)\n- `address` ‚Äì Stores Ethereum wallet addresses (like a unique house address).\n\n#### Example:\n```solidity\naddress public myWallet = 0x1234567890abcdef1234567890abcdef12345678;\n```\n\n### e) Bytes (Raw Data)\n- `bytes` ‚Äì Stores raw data like a file or a secret code.\n\n#### Example:\n```solidity\nbytes32 public secretCode = "0xabcdef123456";\n```\n\nWhy use `bytes` instead of `string`?\n- `string` is easier to read but costs more gas (expensive).\n- `bytes` is cheaper and faster for short data.\n\n## 3. Variables in Solidity\n\nVariables in Solidity store data, but where they are stored matters!\n\n### a) State Variables (Permanent Data)\n- Stored permanently on the blockchain (like a file saved forever).\n- Used inside a contract but outside functions.\n\n#### Example:\n```solidity\ncontract Example {\n    uint public myAge = 25; // Stored on the blockchain\n}\n```\n\n### b) Local Variables (Temporary Data)\n- Only exist inside a function.\n- Not stored on the blockchain (so they don\'t use gas).\n\n#### Example:\n```solidity\ncontract Example {\n    function addNumbers() public pure returns (uint) {\n        uint a = 5; // Local variable\n        uint b = 10;\n        return a + b; // Returns 15\n    }\n}\n```\n\n### c) Global Variables (Blockchain Data)\n- Built-in variables in Solidity that store blockchain-related info.\n\nExamples:\n- `msg.sender` ‚Üí The wallet address of the person interacting with the contract.\n- `block.timestamp` ‚Üí The timestamp of the current block.\n\n#### Example:\n```solidity\ncontract Example {\n    function getSender() public view returns (address) {\n        return msg.sender; // Returns caller\'s address\n    }\n}\n```\n\n## 4. Visibility Specifiers (Who Can See What?)\n\nVisibility determines who can access a function or variable.\n\n| Specifier  | Who Can Access?  |\n|------------|----------------|\n| `public`   | Anyone (inside & outside the contract)  |\n| `private`  | Only inside the contract  |\n| `internal` | Only inside the contract & child contracts  |\n| `external` | Only outside the contract (other contracts can call it)  |\n\n### Example of Visibility in Action\n```solidity\ncontract Example {\n    uint public a = 1;  // Anyone can see\n    uint private b = 2; // Only this contract can see\n    uint internal c = 3; // This contract + child contracts\n}\n```\n\n## Hands-on Activity: Try It Yourself!\n\nNow, open your Solidity Code Editor and play around with these concepts:\n- Declare different data types and test them.\n- Create a public, private, and internal variable and check access.\n- Use `msg.sender` to check your wallet address.\n\nIf you get stuck, our AI suggestions will help you!\n\n## What‚Äôs Next?\n\nIn Lesson 3, we‚Äôll learn how to write functions & modifiers‚Äîbecause contracts without functions are like cars without engines!\n\nStay curious and keep experimenting. See you in the next lesson!',
    },
    {
      id: "solidity-functions",
      title: "Functions & Modifiers",
      content:
        '# Lesson 3: Functions & Modifiers\n\nWelcome back, Solidity explorer! Today, we are making our contracts interactive by exploring **functions**, **parameters**, **return values**, and **modifiers**.\n\n## 1. Writing Functions in Solidity\nA function in Solidity is like a robot‚Äîyou give it commands, and it executes them.\n\n### Example: A Simple Function\n```solidity\nfunction sayHello() public pure returns (string memory) {\n    return "Hello, Solidity!";\n}\n```\n### Breaking it down:\n- `public` ‚Üí Anyone can call it.\n- `pure` ‚Üí It does not interact with blockchain data.\n- `returns (string memory)` ‚Üí Returns a string value.\n\n## 2. View & Pure Functions\nFunctions in Solidity can either **read** blockchain data (`view`) or be **completely independent** (`pure`).\n\n| Function Type  | Reads Data? | Modifies Data? |\n|---------------|------------|---------------|\n| Regular Function | ‚úÖ Yes | ‚úÖ Yes |\n| View Function | ‚úÖ Yes | ‚ùå No |\n| Pure Function | ‚ùå No | ‚ùå No |\n\n### a) View Function Example\n```solidity\ncontract Example {\n    uint public myNumber = 10;\n    function getNumber() public view returns (uint) {\n        return myNumber;\n    }\n}\n```\n### b) Pure Function Example\n```solidity\ncontract Example {\n    function addNumbers(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n}\n```\n\n## 3. Function Parameters & Return Values\nFunctions can **accept inputs** and **return outputs**.\n\n### Example: Coffee Machine\n```solidity\ncontract CoffeeMachine {\n    function makeCoffee(string memory sugarLevel) public pure returns (string memory) {\n        return string(abi.encodePacked("Coffee with ", sugarLevel, " sugar"));\n    }\n}\n```\nCalling `makeCoffee("medium")` returns `Coffee with medium sugar`.\n\n## 4. Function Modifiers (Adding Rules to Functions)\nModifiers help enforce conditions before functions execute.\n\n### a) The `onlyOwner` Modifier (Restricting Access)\n```solidity\ncontract VIPClub {\n    address public owner;\n    constructor() { owner = msg.sender; }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, "You are not the owner!");\n        _;\n    }\n\n    function shutDownClub() public onlyOwner {\n        // Only owner can execute this\n    }\n}\n```\n### b) Creating a Custom Modifier (VIP Access)\n```solidity\ncontract VIPParty {\n    mapping(address => bool) public isVIP;\n\n    function addVIP(address _vip) public {\n        isVIP[_vip] = true;\n    }\n\n    modifier onlyVIP() {\n        require(isVIP[msg.sender], "Sorry, you\'re not on the VIP list!");\n        _;\n    }\n\n    function enterVIPParty() public onlyVIP returns (string memory) {\n        return "Welcome to the VIP party!";\n    }\n}\n```\n---\n\n## Summary & Hands-on Practice\n### Today, you learned:\n‚úî How to write Solidity functions (`public`, `private`, `view`, `pure`).  \n‚úî How to pass parameters and return values.  \n‚úî How to use **modifiers** to restrict function access (`onlyOwner`, `onlyVIP`).\n\n### üî• Challenges:\n1Ô∏è‚É£ Create a **bank contract** where only the owner can withdraw funds.\n2Ô∏è‚É£ Write a function that returns **both the sum and product** of two numbers.\n3Ô∏è‚É£ Implement a **VIP ticketing system** where only selected wallets can buy tickets.\n\n## üöÄ Up Next: Solidity Control Structures & Error Handling\nIn the next lesson, we will explore **conditionals and loops** to make contracts more dynamic.\n\nKeep coding and have fun with Solidity! üöÄ',
    },
    {
      id: "control-structures",
      title: "Control Structures and Error Handling",
      content:
        '# Lesson 4: Control Structures & Error Handling\n\nWelcome back, Solidity sorcerer!\nSo far, we‚Äôve built smart contracts that can store data, use functions, and have rules (modifiers).\n\nBut what if we need decision-making? Like a vending machine that checks your balance before dispensing snacks.\n\nToday, we‚Äôll learn about:\n* **Conditional statements** ‚Äì Making decisions with if-else\n* **Loops** ‚Äì Repeating actions with for, while, and do-while\n* **Error handling** ‚Äì Preventing bugs and bad inputs with require, assert, and revert\n\n## 1. Conditional Statements (if-else)\n\nConditional statements let our contract make decisions, just like a traffic signal.\n\n### Example: A contract checking if a user is old enough to vote (18+).\n\n```solidity\ncontract Voting {\n    function canVote(uint age) public pure returns (string memory) {\n        if (age >= 18) {\n            return "You can vote!";\n        } else {\n            return "Sorry, you are too young!";\n        }\n    }\n}\n```\n\n**Example outputs:**\n* `canVote(20)` ‚Üí "You can vote!"\n* `canVote(16)` ‚Üí "Sorry, you are too young!"\n\n### else if ‚Äì Multiple Conditions\n\n```solidity\ncontract GradeSystem {\n    function getGrade(uint score) public pure returns (string memory) {\n        if (score >= 90) {\n            return "A";\n        } else if (score >= 75) {\n            return "B";\n        } else if (score >= 50) {\n            return "C";\n        } else {\n            return "F";\n        }\n    }\n}\n```\n\n**Example outputs:**\n* `getGrade(85)` ‚Üí "B"\n* `getGrade(40)` ‚Üí "F"\n\n## 2. Loops in Solidity (Repeating Actions)\n\nLoops are useful when we need to repeat tasks without writing the same code multiple times.\n\n| **Loop Type**  | **How it Works**  |\n|---------------|------------------|\n| **for loop**   | Repeats a fixed number of times |\n| **while loop** | Runs while a condition is true |\n| **do-while loop** | Runs at least once, then checks the condition |\n\n### a) for Loop (Counting Repetitions)\n\n```solidity\ncontract Loops {\n    function sumFirstFive() public pure returns (uint sum) {\n        for (uint i = 1; i <= 5; i++) {\n            sum += i;  // Adds 1+2+3+4+5\n        }\n    }\n}\n```\n\n**Output:** `sumFirstFive()` returns `15` (1+2+3+4+5).\n\n### b) while Loop (Repeats Until Condition is False)\n\n```solidity\ncontract Countdown {\n    function countDown() public pure returns (string memory) {\n        uint i = 5;\n        string memory result = "";\n        \n        while (i > 0) {\n            result = string(abi.encodePacked(result, uint2str(i), " "));\n            i--;\n        }\n        \n        return result;\n    }\n}\n```\n\n**Output:** `"5 4 3 2 1 "`\n\n### c) do-while Loop (Always Runs at Least Once)\n\n```solidity\ncontract DoWhileExample {\n    function sayHello(uint count) public pure returns (string memory) {\n        string memory result = "";\n        do {\n            result = string(abi.encodePacked(result, "Hello! "));\n            count--;\n        } while (count > 0);\n        \n        return result;\n    }\n}\n```\n\n**Example outputs:**\n* `sayHello(3)` ‚Üí `"Hello! Hello! Hello! "`\n* `sayHello(0)` ‚Üí `"Hello! "` (Runs once before checking condition.)\n\n## 3. Error Handling (Preventing Bad Inputs & Bugs)\n\nSolidity provides three tools to prevent errors:\n* `require()` ‚Äì Checks conditions before executing code.\n* `assert()` ‚Äì Checks internal errors (should never fail).\n* `revert()` ‚Äì Manually cancels a transaction.\n\n### a) require() (Checking Conditions First)\n\n```solidity\ncontract Bank {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        require(msg.value >= 1 ether, "Minimum deposit is 1 ETH");\n        balances[msg.sender] += msg.value;\n    }\n}\n```\n\n### b) assert() (Checking Internal Logic)\n\n```solidity\ncontract SafeMath {\n    function subtract(uint a, uint b) public pure returns (uint) {\n        uint result = a - b;\n        assert(result <= a);  // Ensure subtraction is correct\n        return result;\n    }\n}\n```\n\n### c) revert() (Manual Error Handling)\n\n```solidity\ncontract VIPAccess {\n    mapping(address => bool) public isVIP;\n\n    function enterClub() public view returns (string memory) {\n        if (!isVIP[msg.sender]) {\n            revert("Access Denied: You are not a VIP!");\n        }\n        return "Welcome, VIP!";\n    }\n}\n```\n\n## Summary & Hands-on Practice!\n\n‚úî if-else statements to make decisions.\n‚úî for, while, and do-while loops to repeat actions.\n‚úî require(), assert(), and revert() to handle errors safely.\n\n### Try These Challenges:\n‚úÖ Write a function that checks if a number is even or odd.\n‚úÖ Create a bank contract that allows only deposits of a minimum of 1 ETH.\n‚úÖ Write a loop that calculates the factorial of a number.\n\nSee you in the next lesson!',
    },
    {
      id: "mappings-structs-arrays",
      title: "Mappings, Structs, and Arrays",
      content:
        '# Lesson 5: Mappings, Structs, and Arrays\n\nWelcome, Solidity explorer!\n\nSo far, we‚Äôve written contracts with variables, functions, and logic‚Äîbut where do we store data efficiently?\n\nImagine you\'re organizing a school:\n- **Arrays** = A list of students (Student #1, Student #2, etc.)\n- **Structs** = A student profile (name, age, grade, etc.)\n- **Mappings** = A phone book (Student Name ‚Üí Phone Number)\n\nToday, we‚Äôll learn:\n- **Arrays** ‚Äì Storing multiple values in a list\n- **Structs** ‚Äì Grouping different data types together\n- **Mappings** ‚Äì Creating key-value pairs (like a dictionary)\n\n### 1. Arrays: Storing Multiple Items\nArrays are like shopping lists‚Äîa collection of items stored in order.\n\n#### Fixed-Size vs. Dynamic Arrays\n| Type | Description |\n|------|------------|\n| **Fixed Array** | Size cannot change (e.g., 5 students max). |\n| **Dynamic Array** | Size can grow/shrink (e.g., adding students dynamically). |\n\n#### a) Fixed-Size Arrays\n**Example: Store 3 favorite numbers**\n```solidity\ncontract FixedArray {\n    uint[3] public favoriteNumbers = [7, 42, 99];\n\n    function getNumber(uint index) public view returns (uint) {\n        return favoriteNumbers[index]; // Get a number from the array\n    }\n}\n```\n- `getNumber(1)` ‚Üí 42 (since arrays start at index 0).\n\n#### b) Dynamic Arrays (Expandable Lists)\n**Example: A growing list of student names**\n```solidity\ncontract StudentList {\n    string[] public students;\n\n    function addStudent(string memory _name) public {\n        students.push(_name);\n    }\n\n    function getStudent(uint index) public view returns (string memory) {\n        return students[index];\n    }\n\n    function getTotalStudents() public view returns (uint) {\n        return students.length;\n    }\n}\n```\n- `addStudent("Alice")` ‚Üí "Alice" added\n- `getTotalStudents()` ‚Üí 1\n\n### 2. Structs: Custom Data Structures\nA struct is like a profile card‚Äîit holds multiple pieces of related data together.\n\n#### Example: Student Struct\n```solidity\ncontract StudentRegistry {\n    struct Student {\n        string name;\n        uint age;\n        string grade;\n    }\n\n    Student public exampleStudent = Student("Alice", 20, "A");\n\n    function createStudent(string memory _name, uint _age, string memory _grade) public pure returns (Student memory) {\n        return Student(_name, _age, _grade);\n    }\n}\n```\n- `createStudent("Bob", 22, "B")` ‚Üí Returns Bob, 22, B\n\n#### Using Structs in an Array\n```solidity\ncontract StudentList {\n    struct Student {\n        string name;\n        uint age;\n    }\n\n    Student[] public students;\n\n    function addStudent(string memory _name, uint _age) public {\n        students.push(Student(_name, _age));\n    }\n\n    function getStudent(uint index) public view returns (string memory, uint) {\n        Student memory s = students[index];\n        return (s.name, s.age);\n    }\n}\n```\n- `addStudent("Charlie", 19)`\n- `getStudent(0)` ‚Üí Returns "Charlie", 19\n\n### 3. Mappings: Key-Value Storage\nMappings are like a phone book‚Äîyou provide a key (like a name) to get a value (like a phone number).\n\n| Key | Value |\n|-----|-------|\n| Alice | 10 ETH |\n| Bob | 5 ETH |\n| Charlie | 0 ETH |\n\nMappings are optimized for fast lookups, but you can‚Äôt loop through them directly.\n\n#### a) Simple Mapping\n```solidity\ncontract Wallet {\n    mapping(address => uint) public balances;\n\n    function setBalance(uint _amount) public {\n        balances[msg.sender] = _amount;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n}\n```\n- `setBalance(100)` ‚Üí Stores 100 for `msg.sender`\n- `getBalance()` ‚Üí Returns 100\n\n#### b) Mapping Structs (Phone Book Example)\n```solidity\ncontract PhoneBook {\n    struct Contact {\n        string name;\n        string phoneNumber;\n    }\n\n    mapping(address => Contact) public contacts;\n\n    function addContact(string memory _name, string memory _phone) public {\n        contacts[msg.sender] = Contact(_name, _phone);\n    }\n\n    function getContact() public view returns (string memory, string memory) {\n        Contact memory c = contacts[msg.sender];\n        return (c.name, c.phoneNumber);\n    }\n}\n```\n- `addContact("Alice", "123-456")`\n- `getContact()` ‚Üí "Alice", "123-456"\n\n### Summary & Hands-on Practice\nToday, we covered:\n- **Arrays** ‚Äì Fixed & dynamic lists of data\n- **Structs** ‚Äì Custom data structures\n- **Mappings** ‚Äì Key-value pairs for fast lookups\n\n#### Try These Challenges:\n1. Create a library system where books are stored as structs inside an array.\n2. Make a mapping that keeps track of a user‚Äôs favorite color.\n3. Store a list of products with name, price, and stock availability.\n\n**What‚Äôs Next?**\nNext time, we‚Äôll explore **Events & Smart Contract Interactions**‚Äîallowing contracts to communicate and log important actions.',
    },
    {
      id: "events-security",
      title: "Events & Smart Contract Security",
      content:
        '# Lesson 6: Events & Smart Contract Security\n\nWelcome back, Solidity explorer. Today, we are diving into **events**, which allow smart contracts to communicate with external applications, and **security**, which ensures contracts are protected from vulnerabilities.\n\n## Events: Let Your Contract Communicate\n\nEvents allow a smart contract to send messages that external applications, such as a frontend or another contract, can listen to and react to.\n\n### Example Scenarios:\n- A user sends Ether ‚Üí A `Transfer` event is emitted.\n- A user places a bet ‚Üí A `BetPlaced` event is emitted.\n\n### Declaring and Emitting Events\n#### Example: Bank Transaction Notifications\n```solidity\ncontract Bank {\n    event Deposit(address indexed user, uint amount); // Event declaration\n\n    function deposit() public payable {\n        emit Deposit(msg.sender, msg.value); // Emit event when function runs\n    }\n}\n```\nWhen the `deposit` function is called, the blockchain logs the event:\n```scss\nDeposit(address user, uint amount)\n```\nThe frontend can listen for this event and show a live notification.\n\n### Indexed Events for Faster Searching\nUsing `indexed` allows filtering specific users in event logs.\n```solidity\nevent Transfer(address indexed from, address indexed to, uint amount);\n```\nWith `indexed`, transactions can be quickly filtered by sender or receiver.\n\n## Common Solidity Vulnerabilities & How to Stay Safe\n\nSmart contracts **cannot be changed once deployed**, so mistakes can lead to **permanent loss of funds**. Below are common security risks and their solutions.\n\n### 1. Reentrancy Attack\nA hacker can repeatedly call a contract **before it updates balances**, draining funds.\n\n#### ‚ùå Vulnerable Contract:\n```solidity\ncontract BadVault {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() public {\n        require(balances[msg.sender] > 0, "No funds");\n        (bool success, ) = msg.sender.call{value: balances[msg.sender]}("");\n        require(success, "Transfer failed");\n        balances[msg.sender] = 0; // Update balance AFTER transfer\n    }\n}\n```\nüö® **Problem:** The attacker can repeatedly call `withdraw` before the balance is updated.\n\n#### ‚úÖ Solution: Use the "Checks-Effects-Interactions" Pattern\n```solidity\nfunction withdraw() public {\n    uint amount = balances[msg.sender];\n    require(amount > 0, "No funds");\n\n    balances[msg.sender] = 0; // Update balance FIRST\n    (bool success, ) = msg.sender.call{value: amount}("");\n    require(success, "Transfer failed");\n}\n```\nThis ensures that the balance is cleared before making the external call, **preventing reentrancy**.\n\n### 2. Integer Overflow & Underflow\nIf numbers exceed their **maximum value (overflow)** or go **below zero (underflow)**, the contract may break.\n\n#### ‚ùå Vulnerable Contract:\n```solidity\ncontract BadMath {\n    uint8 public num = 255; // Max value for uint8\n\n    function add() public {\n        num += 1; // Overflow! Resets to 0\n    }\n}\n```\n#### ‚úÖ Solution: Use SafeMath (or Solidity 0.8+, which has built-in checks)\n```solidity\nfunction add() public {\n    unchecked { num += 1; } // Use unchecked only if safe\n}\n```\nSolidity **0.8+ prevents overflows by default**, eliminating silent resets.\n\n### 3. SelfDestruct Function\nSome contracts include a `selfdestruct` function that, if **improperly secured**, allows **anyone to delete the contract permanently**.\n\n#### ‚ùå Vulnerable Contract:\n```solidity\ncontract BadContract {\n    function destroy() public {\n        selfdestruct(payable(msg.sender)); // Anyone can destroy the contract\n    }\n}\n```\n#### ‚úÖ Solution: Restrict `selfdestruct` to the Owner\n```solidity\ncontract SafeContract {\n    address private owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function destroy() public {\n        require(msg.sender == owner, "Not the owner!"); // Only owner can call\n        selfdestruct(payable(owner));\n    }\n}\n```\nThis ensures **only the contract owner** can delete it.\n\n### 4. Access Control Flaws\nIf functions **are not restricted**, anyone can call them and modify critical contract variables.\n\n#### ‚ùå Vulnerable Contract:\n```solidity\ncontract BadOwner {\n    address public owner;\n\n    function changeOwner(address newOwner) public {\n        owner = newOwner; // Anyone can take over the contract\n    }\n}\n```\n#### ‚úÖ Solution: Use an `onlyOwner` Modifier\n```solidity\ncontract SafeOwner {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, "Not the owner!");\n        _;\n    }\n\n    function changeOwner(address newOwner) public onlyOwner {\n        owner = newOwner; // Only owner can update\n    }\n}\n```\nThis ensures **only the original owner** can change ownership.\n\n## Best Practices for Secure Smart Contracts\n‚úÖ Use `onlyOwner` or `require(msg.sender == owner)` for critical functions.\n‚úÖ Always update balances **before making external calls** to prevent **reentrancy attacks**.\n‚úÖ Use Solidity **0.8+ to avoid integer overflows**.\n‚úÖ Emit **events** for important actions such as transfers and contract changes.\n‚úÖ **Never expose** `selfdestruct` unless absolutely necessary.\n\n## Summary & Hands-on Practice\nToday, we covered:\n- **Events** ‚Äì Solidity‚Äôs way of sending notifications.\n- **Reentrancy Attacks** ‚Äì How to prevent funds from being drained.\n- **Integer Overflow/Underflow** ‚Äì Avoiding silent math errors.\n- **SelfDestruct & Access Control** ‚Äì Protecting contracts from unauthorized access.\n\n### üî• Challenges:\n1Ô∏è‚É£ Create a contract where users can buy tokens, **emitting an event** each time.\n2Ô∏è‚É£ Implement a **secure withdrawal function** that prevents **reentrancy**.\n3Ô∏è‚É£ Build a **vault contract** with `onlyOwner` to change security settings.\n\n## üöÄ Up Next: Solidity Inheritance & Smart Contract Structuring\nIn the next lesson, we will learn how **smart contracts inherit** from each other, similar to **parent-child relationships** in code.\n\n**Keep coding and continue making Solidity contracts more secure!**',
    },
    {
      id: "inheritance-advanced-concepts",
      title: "Inheritance & Advanced Concepts",
      content:
        '# Lesson 7: Inheritance & Advanced Concepts\n\nWelcome back, Solidity explorer! Today, we‚Äôre diving into **inheritance** (letting contracts share features), **interfaces & abstract contracts** (setting rules for others to follow), and an **introduction to the ERC-20 & ERC-721 token standards**.\n\n---\n\n### 1. Inheritance in Solidity: Like Parents & Children\nThink of Solidity inheritance like a family tree:\n- **Parent contracts (base contracts)** define general functions.\n- **Child contracts (derived contracts)** inherit those functions and can add or modify them.\n\n#### Example: Basic Inheritance\n```solidity\n// Parent Contract (Base Contract)\ncontract Animal {\n    string public species;\n\n    function setSpecies(string memory _species) public {\n        species = _species;\n    }\n}\n\n// Child Contract (Derived Contract)\ncontract Dog is Animal {\n    string public name;\n\n    function setName(string memory _name) public {\n        name = _name;\n    }\n}\n```\n**Explanation:**\n- `Dog` inherits all properties of `Animal`.\n- `Dog` can still add `setName()` (specific to Dog).\n\n#### Overriding Functions (Modifying Parent Behavior)\n```solidity\ncontract Animal {\n    function makeSound() public pure virtual returns (string memory) {\n        return "Some generic animal sound";\n    }\n}\n\ncontract Dog is Animal {\n    function makeSound() public pure override returns (string memory) {\n        return "Woof! Woof!";\n    }\n}\n```\n**Explanation:**\n- The `virtual` keyword in `Animal` allows overriding.\n- The `override` keyword in `Dog` changes the function‚Äôs behavior.\n\n---\n\n### 2. Interfaces & Abstract Contracts\nInterfaces and abstract contracts define rules for how other contracts should behave.\n\n#### **Interfaces: Must-Implement Rules**\n```solidity\ninterface Vehicle {\n    function start() external;\n    function stop() external;\n}\n\ncontract Car is Vehicle {\n    function start() external override {\n        // Code to start the car\n    }\n    function stop() external override {\n        // Code to stop the car\n    }\n}\n```\n**Explanation:**\n- `Vehicle` is an interface‚Äîany contract using it **must** implement `start()` and `stop()`.\n- `Car` follows the blueprint, ensuring every car has a way to start and stop.\n\n#### **Abstract Contracts: Partially Built Houses**\n```solidity\nabstract contract Bank {\n    function deposit() public virtual;\n    function withdraw() public virtual;\n}\n\ncontract MyBank is Bank {\n    function deposit() public override {\n        // Code for depositing money\n    }\n    function withdraw() public override {\n        // Code for withdrawing money\n    }\n}\n```\n**Explanation:**\n- `Bank` is abstract, meaning **it cannot be deployed alone**.\n- `MyBank` completes it by defining `deposit()` and `withdraw()`.\n\n---\n\n### 3. Working with ERC-20 & ERC-721 Standards\nSolidity has established standards for tokens, making them easy to integrate across platforms.\n\n#### **ERC-20: Fungible tokens** (identical & interchangeable, like USD or Bitcoin)\n##### Basic ERC-20 functions:\n- `totalSupply()` ‚Üí Total tokens in existence\n- `balanceOf()` ‚Üí Check token balance of an address\n- `transfer()` ‚Üí Move tokens between users\n\n```solidity\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address account) external view returns (uint);\n    function transfer(address recipient, uint amount) external returns (bool);\n}\n```\n**Every ERC-20 token must follow this standard.**\n\n#### **ERC-721: NFTs (Unique Digital Assets)**\n##### Basic ERC-721 functions:\n- `ownerOf(tokenId)` ‚Üí Who owns this NFT?\n- `transferFrom()` ‚Üí Move the NFT to someone else\n- `mint()` ‚Üí Create a new NFT\n\n```solidity\ninterface IERC721 {\n    function ownerOf(uint tokenId) external view returns (address);\n    function transferFrom(address from, address to, uint tokenId) external;\n}\n```\n**Every NFT contract must include these functions.**\n\n---\n\n## Course Wrap-Up\nüéâ **Congratulations!** You now understand Solidity basics and can write smart contracts.\n\n### **Key Takeaways from the Course**\n‚úÖ Solidity syntax & smart contract structure  \n‚úÖ Variables, functions, and control structures  \n‚úÖ Mappings, structs, and arrays  \n‚úÖ Events & smart contract security  \n‚úÖ Inheritance, interfaces, and ERC-20/ERC-721  \n\n### **Next Steps & Practice Challenges**\nüîπ **Build a bank contract** that inherits from a base contract.  \nüîπ **Create a simple ERC-20 token** with transfer functionality.  \nüîπ **Make an NFT contract** that mints unique digital collectibles.  \n\nüìå **In the next course, we‚Äôll dive into deploying contracts on a real blockchain.**  \nKeep learning, keep building, and **welcome to the world of Web3!** üöÄ\n',
    },
  ],
};
