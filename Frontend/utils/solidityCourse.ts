export const courses = [
  {
    id: "basics-of-solidity",
    title: "Basics of Solidity",
    description:
      "Learn the fundamentals of Solidity programming and smart contract development for blockchain applications.",
    level: "Beginner" as "Beginner",
    duration: "4 weeks",
    lessonCount: 7,
    tags: ["solidity", "basics"],
    registrations: 0,
    image: "/images/solidity-basics.png",
    lessons: [
      {
        id: "intro-to-solidity",
        title: "Introduction to Solidity & Smart Contracts",
        content:
          "# Lesson 1: Introduction to Solidity & Smart Contracts\n\nHey there, future blockchain developer! Welcome to the world of Solidity! If you've ever wondered, \"What exactly is a smart contract, and why is everyone talking about it?\"‚Äîyou're in the right place. Let's break it down without any complex jargon and have some fun along the way.\n\n---\n\n## What is Solidity?\n\nImagine you are writing a magic spell, but instead of controlling mythical creatures, your spell controls money, ownership, and agreements on the blockchain. Solidity is the language used to write these spells (smart contracts).\n\nIt's similar to JavaScript but with some extra features. With Solidity, you can create self-executing agreements that nobody can change or tamper with‚Äînot even you after deploying them.\n\n---\n\n## What are Smart Contracts?\n\nThink of a smart contract as a vending machine:\n- You put money in (send cryptocurrency).\n- You select your snack (trigger a function).\n- The vending machine checks if you inserted the correct amount (validates conditions).\n- If yes, it automatically drops your snack (executes the function).\n\nNo shopkeeper is needed. No middleman. Just instant execution based on clear rules written in Solidity.\n\n### Another way to think about it:\n- **Normal contracts** are written on paper and need lawyers to enforce them.\n- **Smart contracts** are written in code and enforce themselves automatically.\n\nBlockchain ensures nobody can cheat, because once a smart contract is deployed, it runs exactly as written.\n\n---\n\n## Use Cases of Smart Contracts\n\nNow that we know what smart contracts are, let's check out where they're used in real life:\n\n‚úÖ **Decentralized Finance (DeFi)** ‚Äì Borrow, lend, and trade crypto without banks.  \n‚úÖ **NFTs** ‚Äì Own unique digital art, music, or in-game items.  \n‚úÖ **Supply Chain** ‚Äì Track where products come from without trusting middlemen.  \n‚úÖ **Ticketing** ‚Äì Buy concert tickets that can't be counterfeited.  \n‚úÖ **Voting Systems** ‚Äì Fair elections without fraud.  \n\nSmart contracts remove middlemen and make processes more transparent. No trust issues, no hidden fees‚Äîjust pure automation.\n\n---\n\n## Writing a Simple \"Hello World\" Smart Contract\n\nNow, let's write our first Solidity program.\n\nIf you've coded before, you might remember that in most programming languages, the first thing we write is a \"Hello, World!\" program. It's like saying hello to the language.\n\n### Here‚Äôs what it looks like in Solidity:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract HelloWorld {\n    string public message = \"Hello, World!\";\n}\n```\n\n### Breaking it down:\n- `pragma solidity ^0.8.0;` ‚Üí Tells the compiler which Solidity version to use.\n- `contract HelloWorld {}` ‚Üí Defines a smart contract named \"HelloWorld\".\n- `string public message = \"Hello, World!\";` ‚Üí A public variable storing the message.\n\n### What this contract does:\n- It stores a \"Hello, World!\" message.\n- Since the variable is public, anyone can read it.\n\nSimple, right? You just wrote your first smart contract! üéâ\n\n---\n\n## Try It Yourself\n\nNow, head over to our **Solidity Code Editor** and type it in. Hit **Compile** and see if it works!\n\n‚úÖ **If it compiles successfully**, congrats! You've just taken your first step into blockchain development.  \n‚ùå **If there's an error**, don‚Äôt worry‚Äîour AI suggestions will help you fix it.  \n\n---\n\n## What's Next?\n\nIn the next lesson, we'll explore **Solidity‚Äôs syntax and data types**‚Äîit‚Äôs like learning the alphabet before writing full sentences. Stay curious and keep experimenting. See you in **Lesson 2!** üöÄ\n",
      },
      {
        id: "solidity-syntax",
        title: "Solidity Syntax and Data Types",
        content:
          '# Lesson 2: Solidity Syntax & Data Types\n\nWelcome back, blockchain developer!  \nNow that you\'ve said Hello, World! in Solidity, let‚Äôs break down the language itself‚Äîkind of like understanding the grammar of a new language before writing full stories.\n\nSolidity is simple, but it does have its own rules and structure. Let‚Äôs explore!\n\n## 1. Structure of a Solidity Smart Contract\n\nThink of a Solidity contract like a recipe.\n\nA recipe has:\n1. Title (Contract name)\n2. Ingredients (State variables)\n3. Instructions (Functions)\n\nHere\'s a basic Solidity contract skeleton:\n\n```solidity\n// Step 1: Declare the version\npragma solidity ^0.8.0;\n\n// Step 2: Define the contract\ncontract MyFirstContract {\n    \n    // Step 3: Declare variables\n    string public myMessage = "Hello, Solidity!";\n    \n    // Step 4: Write functions\n    function setMessage(string memory newMessage) public {\n        myMessage = newMessage;\n    }\n}\n```\n\n### Breakdown:\n- `pragma solidity ^0.8.0;` ‚Üí Solidity version (like saying ‚Äúwe‚Äôre using the latest English dictionary‚Äù).\n- `contract MyFirstContract {}` ‚Üí The blueprint of our smart contract.\n- `string public myMessage = "Hello, Solidity!";` ‚Üí A public state variable storing a message.\n- `function setMessage(string memory newMessage) public {}` ‚Üí A function to change the message.\n\nEasy, right? Now, let‚Äôs talk about data types‚Äîthe building blocks of Solidity!\n\n## 2. Solidity Data Types\n\nIn Solidity, we store and process data using different types. Think of them like different kinds of containers in a kitchen.\n\n### a) Numbers (uint & int)\n- `uint` (Unsigned Integer) ‚Äì Whole numbers that are only positive (like 0, 1, 2, 100).\n- `int` (Signed Integer) ‚Äì Whole numbers that can be both positive & negative (like -5, 0, 42).\n\n#### Example:\n```solidity\nuint256 public positiveNumber = 42;  // Stores 42\nint256 public negativeNumber = -42;  // Stores -42\n```\n\n### b) Strings (Words & Sentences)\n- `string` ‚Äì Stores text, like a note in a diary.\n\n#### Example:\n```solidity\nstring public name = "Solidity"; \n```\n\nWhy use `memory`?  \nWhen passing a string in a function, Solidity needs to know where to store it (temporarily or permanently). We‚Äôll cover this later.\n\n### c) Boolean (True/False)\n- `bool` ‚Äì Think of it as a light switch: ON (true) or OFF (false).\n\n#### Example:\n```solidity\nbool public isCodingFun = true;\n```\n\n### d) Address (Wallet Address)\n- `address` ‚Äì Stores Ethereum wallet addresses (like a unique house address).\n\n#### Example:\n```solidity\naddress public myWallet = 0x1234567890abcdef1234567890abcdef12345678;\n```\n\n### e) Bytes (Raw Data)\n- `bytes` ‚Äì Stores raw data like a file or a secret code.\n\n#### Example:\n```solidity\nbytes32 public secretCode = "0xabcdef123456";\n```\n\nWhy use `bytes` instead of `string`?\n- `string` is easier to read but costs more gas (expensive).\n- `bytes` is cheaper and faster for short data.\n\n## 3. Variables in Solidity\n\nVariables in Solidity store data, but where they are stored matters!\n\n### a) State Variables (Permanent Data)\n- Stored permanently on the blockchain (like a file saved forever).\n- Used inside a contract but outside functions.\n\n#### Example:\n```solidity\ncontract Example {\n    uint public myAge = 25; // Stored on the blockchain\n}\n```\n\n### b) Local Variables (Temporary Data)\n- Only exist inside a function.\n- Not stored on the blockchain (so they don\'t use gas).\n\n#### Example:\n```solidity\ncontract Example {\n    function addNumbers() public pure returns (uint) {\n        uint a = 5; // Local variable\n        uint b = 10;\n        return a + b; // Returns 15\n    }\n}\n```\n\n### c) Global Variables (Blockchain Data)\n- Built-in variables in Solidity that store blockchain-related info.\n\nExamples:\n- `msg.sender` ‚Üí The wallet address of the person interacting with the contract.\n- `block.timestamp` ‚Üí The timestamp of the current block.\n\n#### Example:\n```solidity\ncontract Example {\n    function getSender() public view returns (address) {\n        return msg.sender; // Returns caller\'s address\n    }\n}\n```\n\n## 4. Visibility Specifiers (Who Can See What?)\n\nVisibility determines who can access a function or variable.\n\n| Specifier  | Who Can Access?  |\n|------------|----------------|\n| `public`   | Anyone (inside & outside the contract)  |\n| `private`  | Only inside the contract  |\n| `internal` | Only inside the contract & child contracts  |\n| `external` | Only outside the contract (other contracts can call it)  |\n\n### Example of Visibility in Action\n```solidity\ncontract Example {\n    uint public a = 1;  // Anyone can see\n    uint private b = 2; // Only this contract can see\n    uint internal c = 3; // This contract + child contracts\n}\n```\n\n## Hands-on Activity: Try It Yourself!\n\nNow, open your Solidity Code Editor and play around with these concepts:\n- Declare different data types and test them.\n- Create a public, private, and internal variable and check access.\n- Use `msg.sender` to check your wallet address.\n\nIf you get stuck, our AI suggestions will help you!\n\n## What‚Äôs Next?\n\nIn Lesson 3, we‚Äôll learn how to write functions & modifiers‚Äîbecause contracts without functions are like cars without engines!\n\nStay curious and keep experimenting. See you in the next lesson!',
      },
      {
        id: "solidity-functions",
        title: "Functions & Modifiers",
        content:
          '# Lesson 3: Functions & Modifiers\n\nWelcome back, Solidity explorer! Today, we are making our contracts interactive by exploring **functions**, **parameters**, **return values**, and **modifiers**.\n\n## 1. Writing Functions in Solidity\nA function in Solidity is like a robot‚Äîyou give it commands, and it executes them.\n\n### Example: A Simple Function\n```solidity\nfunction sayHello() public pure returns (string memory) {\n    return "Hello, Solidity!";\n}\n```\n### Breaking it down:\n- `public` ‚Üí Anyone can call it.\n- `pure` ‚Üí It does not interact with blockchain data.\n- `returns (string memory)` ‚Üí Returns a string value.\n\n## 2. View & Pure Functions\nFunctions in Solidity can either **read** blockchain data (`view`) or be **completely independent** (`pure`).\n\n| Function Type  | Reads Data? | Modifies Data? |\n|---------------|------------|---------------|\n| Regular Function | ‚úÖ Yes | ‚úÖ Yes |\n| View Function | ‚úÖ Yes | ‚ùå No |\n| Pure Function | ‚ùå No | ‚ùå No |\n\n### a) View Function Example\n```solidity\ncontract Example {\n    uint public myNumber = 10;\n    function getNumber() public view returns (uint) {\n        return myNumber;\n    }\n}\n```\n### b) Pure Function Example\n```solidity\ncontract Example {\n    function addNumbers(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n}\n```\n\n## 3. Function Parameters & Return Values\nFunctions can **accept inputs** and **return outputs**.\n\n### Example: Coffee Machine\n```solidity\ncontract CoffeeMachine {\n    function makeCoffee(string memory sugarLevel) public pure returns (string memory) {\n        return string(abi.encodePacked("Coffee with ", sugarLevel, " sugar"));\n    }\n}\n```\nCalling `makeCoffee("medium")` returns `Coffee with medium sugar`.\n\n## 4. Function Modifiers (Adding Rules to Functions)\nModifiers help enforce conditions before functions execute.\n\n### a) The `onlyOwner` Modifier (Restricting Access)\n```solidity\ncontract VIPClub {\n    address public owner;\n    constructor() { owner = msg.sender; }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, "You are not the owner!");\n        _;\n    }\n\n    function shutDownClub() public onlyOwner {\n        // Only owner can execute this\n    }\n}\n```\n### b) Creating a Custom Modifier (VIP Access)\n```solidity\ncontract VIPParty {\n    mapping(address => bool) public isVIP;\n\n    function addVIP(address _vip) public {\n        isVIP[_vip] = true;\n    }\n\n    modifier onlyVIP() {\n        require(isVIP[msg.sender], "Sorry, you\'re not on the VIP list!");\n        _;\n    }\n\n    function enterVIPParty() public onlyVIP returns (string memory) {\n        return "Welcome to the VIP party!";\n    }\n}\n```\n---\n\n## Summary & Hands-on Practice\n### Today, you learned:\n‚úî How to write Solidity functions (`public`, `private`, `view`, `pure`).  \n‚úî How to pass parameters and return values.  \n‚úî How to use **modifiers** to restrict function access (`onlyOwner`, `onlyVIP`).\n\n### üî• Challenges:\n1Ô∏è‚É£ Create a **bank contract** where only the owner can withdraw funds.\n2Ô∏è‚É£ Write a function that returns **both the sum and product** of two numbers.\n3Ô∏è‚É£ Implement a **VIP ticketing system** where only selected wallets can buy tickets.\n\n## üöÄ Up Next: Solidity Control Structures & Error Handling\nIn the next lesson, we will explore **conditionals and loops** to make contracts more dynamic.\n\nKeep coding and have fun with Solidity! üöÄ',
      },
      {
        id: "control-structures",
        title: "Control Structures and Error Handling",
        content:
          '# Lesson 4: Control Structures & Error Handling\n\nWelcome back, Solidity sorcerer!\nSo far, we‚Äôve built smart contracts that can store data, use functions, and have rules (modifiers).\n\nBut what if we need decision-making? Like a vending machine that checks your balance before dispensing snacks.\n\nToday, we‚Äôll learn about:\n* **Conditional statements** ‚Äì Making decisions with if-else\n* **Loops** ‚Äì Repeating actions with for, while, and do-while\n* **Error handling** ‚Äì Preventing bugs and bad inputs with require, assert, and revert\n\n## 1. Conditional Statements (if-else)\n\nConditional statements let our contract make decisions, just like a traffic signal.\n\n### Example: A contract checking if a user is old enough to vote (18+).\n\n```solidity\ncontract Voting {\n    function canVote(uint age) public pure returns (string memory) {\n        if (age >= 18) {\n            return "You can vote!";\n        } else {\n            return "Sorry, you are too young!";\n        }\n    }\n}\n```\n\n**Example outputs:**\n* `canVote(20)` ‚Üí "You can vote!"\n* `canVote(16)` ‚Üí "Sorry, you are too young!"\n\n### else if ‚Äì Multiple Conditions\n\n```solidity\ncontract GradeSystem {\n    function getGrade(uint score) public pure returns (string memory) {\n        if (score >= 90) {\n            return "A";\n        } else if (score >= 75) {\n            return "B";\n        } else if (score >= 50) {\n            return "C";\n        } else {\n            return "F";\n        }\n    }\n}\n```\n\n**Example outputs:**\n* `getGrade(85)` ‚Üí "B"\n* `getGrade(40)` ‚Üí "F"\n\n## 2. Loops in Solidity (Repeating Actions)\n\nLoops are useful when we need to repeat tasks without writing the same code multiple times.\n\n| **Loop Type**  | **How it Works**  |\n|---------------|------------------|\n| **for loop**   | Repeats a fixed number of times |\n| **while loop** | Runs while a condition is true |\n| **do-while loop** | Runs at least once, then checks the condition |\n\n### a) for Loop (Counting Repetitions)\n\n```solidity\ncontract Loops {\n    function sumFirstFive() public pure returns (uint sum) {\n        for (uint i = 1; i <= 5; i++) {\n            sum += i;  // Adds 1+2+3+4+5\n        }\n    }\n}\n```\n\n**Output:** `sumFirstFive()` returns `15` (1+2+3+4+5).\n\n### b) while Loop (Repeats Until Condition is False)\n\n```solidity\ncontract Countdown {\n    function countDown() public pure returns (string memory) {\n        uint i = 5;\n        string memory result = "";\n        \n        while (i > 0) {\n            result = string(abi.encodePacked(result, uint2str(i), " "));\n            i--;\n        }\n        \n        return result;\n    }\n}\n```\n\n**Output:** `"5 4 3 2 1 "`\n\n### c) do-while Loop (Always Runs at Least Once)\n\n```solidity\ncontract DoWhileExample {\n    function sayHello(uint count) public pure returns (string memory) {\n        string memory result = "";\n        do {\n            result = string(abi.encodePacked(result, "Hello! "));\n            count--;\n        } while (count > 0);\n        \n        return result;\n    }\n}\n```\n\n**Example outputs:**\n* `sayHello(3)` ‚Üí `"Hello! Hello! Hello! "`\n* `sayHello(0)` ‚Üí `"Hello! "` (Runs once before checking condition.)\n\n## 3. Error Handling (Preventing Bad Inputs & Bugs)\n\nSolidity provides three tools to prevent errors:\n* `require()` ‚Äì Checks conditions before executing code.\n* `assert()` ‚Äì Checks internal errors (should never fail).\n* `revert()` ‚Äì Manually cancels a transaction.\n\n### a) require() (Checking Conditions First)\n\n```solidity\ncontract Bank {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        require(msg.value >= 1 ether, "Minimum deposit is 1 ETH");\n        balances[msg.sender] += msg.value;\n    }\n}\n```\n\n### b) assert() (Checking Internal Logic)\n\n```solidity\ncontract SafeMath {\n    function subtract(uint a, uint b) public pure returns (uint) {\n        uint result = a - b;\n        assert(result <= a);  // Ensure subtraction is correct\n        return result;\n    }\n}\n```\n\n### c) revert() (Manual Error Handling)\n\n```solidity\ncontract VIPAccess {\n    mapping(address => bool) public isVIP;\n\n    function enterClub() public view returns (string memory) {\n        if (!isVIP[msg.sender]) {\n            revert("Access Denied: You are not a VIP!");\n        }\n        return "Welcome, VIP!";\n    }\n}\n```\n\n## Summary & Hands-on Practice!\n\n‚úî if-else statements to make decisions.\n‚úî for, while, and do-while loops to repeat actions.\n‚úî require(), assert(), and revert() to handle errors safely.\n\n### Try These Challenges:\n‚úÖ Write a function that checks if a number is even or odd.\n‚úÖ Create a bank contract that allows only deposits of a minimum of 1 ETH.\n‚úÖ Write a loop that calculates the factorial of a number.\n\nSee you in the next lesson!',
      },
      {
        id: "mappings-structs-arrays",
        title: "Mappings, Structs, and Arrays",
        content:
          '# Lesson 5: Mappings, Structs, and Arrays\n\nWelcome, Solidity explorer!\n\nSo far, we‚Äôve written contracts with variables, functions, and logic‚Äîbut where do we store data efficiently?\n\nImagine you\'re organizing a school:\n- **Arrays** = A list of students (Student #1, Student #2, etc.)\n- **Structs** = A student profile (name, age, grade, etc.)\n- **Mappings** = A phone book (Student Name ‚Üí Phone Number)\n\nToday, we‚Äôll learn:\n- **Arrays** ‚Äì Storing multiple values in a list\n- **Structs** ‚Äì Grouping different data types together\n- **Mappings** ‚Äì Creating key-value pairs (like a dictionary)\n\n### 1. Arrays: Storing Multiple Items\nArrays are like shopping lists‚Äîa collection of items stored in order.\n\n#### Fixed-Size vs. Dynamic Arrays\n| Type | Description |\n|------|------------|\n| **Fixed Array** | Size cannot change (e.g., 5 students max). |\n| **Dynamic Array** | Size can grow/shrink (e.g., adding students dynamically). |\n\n#### a) Fixed-Size Arrays\n**Example: Store 3 favorite numbers**\n```solidity\ncontract FixedArray {\n    uint[3] public favoriteNumbers = [7, 42, 99];\n\n    function getNumber(uint index) public view returns (uint) {\n        return favoriteNumbers[index]; // Get a number from the array\n    }\n}\n```\n- `getNumber(1)` ‚Üí 42 (since arrays start at index 0).\n\n#### b) Dynamic Arrays (Expandable Lists)\n**Example: A growing list of student names**\n```solidity\ncontract StudentList {\n    string[] public students;\n\n    function addStudent(string memory _name) public {\n        students.push(_name);\n    }\n\n    function getStudent(uint index) public view returns (string memory) {\n        return students[index];\n    }\n\n    function getTotalStudents() public view returns (uint) {\n        return students.length;\n    }\n}\n```\n- `addStudent("Alice")` ‚Üí "Alice" added\n- `getTotalStudents()` ‚Üí 1\n\n### 2. Structs: Custom Data Structures\nA struct is like a profile card‚Äîit holds multiple pieces of related data together.\n\n#### Example: Student Struct\n```solidity\ncontract StudentRegistry {\n    struct Student {\n        string name;\n        uint age;\n        string grade;\n    }\n\n    Student public exampleStudent = Student("Alice", 20, "A");\n\n    function createStudent(string memory _name, uint _age, string memory _grade) public pure returns (Student memory) {\n        return Student(_name, _age, _grade);\n    }\n}\n```\n- `createStudent("Bob", 22, "B")` ‚Üí Returns Bob, 22, B\n\n#### Using Structs in an Array\n```solidity\ncontract StudentList {\n    struct Student {\n        string name;\n        uint age;\n    }\n\n    Student[] public students;\n\n    function addStudent(string memory _name, uint _age) public {\n        students.push(Student(_name, _age));\n    }\n\n    function getStudent(uint index) public view returns (string memory, uint) {\n        Student memory s = students[index];\n        return (s.name, s.age);\n    }\n}\n```\n- `addStudent("Charlie", 19)`\n- `getStudent(0)` ‚Üí Returns "Charlie", 19\n\n### 3. Mappings: Key-Value Storage\nMappings are like a phone book‚Äîyou provide a key (like a name) to get a value (like a phone number).\n\n| Key | Value |\n|-----|-------|\n| Alice | 10 ETH |\n| Bob | 5 ETH |\n| Charlie | 0 ETH |\n\nMappings are optimized for fast lookups, but you can‚Äôt loop through them directly.\n\n#### a) Simple Mapping\n```solidity\ncontract Wallet {\n    mapping(address => uint) public balances;\n\n    function setBalance(uint _amount) public {\n        balances[msg.sender] = _amount;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n}\n```\n- `setBalance(100)` ‚Üí Stores 100 for `msg.sender`\n- `getBalance()` ‚Üí Returns 100\n\n#### b) Mapping Structs (Phone Book Example)\n```solidity\ncontract PhoneBook {\n    struct Contact {\n        string name;\n        string phoneNumber;\n    }\n\n    mapping(address => Contact) public contacts;\n\n    function addContact(string memory _name, string memory _phone) public {\n        contacts[msg.sender] = Contact(_name, _phone);\n    }\n\n    function getContact() public view returns (string memory, string memory) {\n        Contact memory c = contacts[msg.sender];\n        return (c.name, c.phoneNumber);\n    }\n}\n```\n- `addContact("Alice", "123-456")`\n- `getContact()` ‚Üí "Alice", "123-456"\n\n### Summary & Hands-on Practice\nToday, we covered:\n- **Arrays** ‚Äì Fixed & dynamic lists of data\n- **Structs** ‚Äì Custom data structures\n- **Mappings** ‚Äì Key-value pairs for fast lookups\n\n#### Try These Challenges:\n1. Create a library system where books are stored as structs inside an array.\n2. Make a mapping that keeps track of a user‚Äôs favorite color.\n3. Store a list of products with name, price, and stock availability.\n\n**What‚Äôs Next?**\nNext time, we‚Äôll explore **Events & Smart Contract Interactions**‚Äîallowing contracts to communicate and log important actions.',
      },
      {
        id: "events-security",
        title: "Events & Smart Contract Security",
        content:
          '# Lesson 6: Events & Smart Contract Security\n\nWelcome back, Solidity explorer. Today, we are diving into **events**, which allow smart contracts to communicate with external applications, and **security**, which ensures contracts are protected from vulnerabilities.\n\n## Events: Let Your Contract Communicate\n\nEvents allow a smart contract to send messages that external applications, such as a frontend or another contract, can listen to and react to.\n\n### Example Scenarios:\n- A user sends Ether ‚Üí A `Transfer` event is emitted.\n- A user places a bet ‚Üí A `BetPlaced` event is emitted.\n\n### Declaring and Emitting Events\n#### Example: Bank Transaction Notifications\n```solidity\ncontract Bank {\n    event Deposit(address indexed user, uint amount); // Event declaration\n\n    function deposit() public payable {\n        emit Deposit(msg.sender, msg.value); // Emit event when function runs\n    }\n}\n```\nWhen the `deposit` function is called, the blockchain logs the event:\n```scss\nDeposit(address user, uint amount)\n```\nThe frontend can listen for this event and show a live notification.\n\n### Indexed Events for Faster Searching\nUsing `indexed` allows filtering specific users in event logs.\n```solidity\nevent Transfer(address indexed from, address indexed to, uint amount);\n```\nWith `indexed`, transactions can be quickly filtered by sender or receiver.\n\n## Common Solidity Vulnerabilities & How to Stay Safe\n\nSmart contracts **cannot be changed once deployed**, so mistakes can lead to **permanent loss of funds**. Below are common security risks and their solutions.\n\n### 1. Reentrancy Attack\nA hacker can repeatedly call a contract **before it updates balances**, draining funds.\n\n#### ‚ùå Vulnerable Contract:\n```solidity\ncontract BadVault {\n    mapping(address => uint) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() public {\n        require(balances[msg.sender] > 0, "No funds");\n        (bool success, ) = msg.sender.call{value: balances[msg.sender]}("");\n        require(success, "Transfer failed");\n        balances[msg.sender] = 0; // Update balance AFTER transfer\n    }\n}\n```\nüö® **Problem:** The attacker can repeatedly call `withdraw` before the balance is updated.\n\n#### ‚úÖ Solution: Use the "Checks-Effects-Interactions" Pattern\n```solidity\nfunction withdraw() public {\n    uint amount = balances[msg.sender];\n    require(amount > 0, "No funds");\n\n    balances[msg.sender] = 0; // Update balance FIRST\n    (bool success, ) = msg.sender.call{value: amount}("");\n    require(success, "Transfer failed");\n}\n```\nThis ensures that the balance is cleared before making the external call, **preventing reentrancy**.\n\n### 2. Integer Overflow & Underflow\nIf numbers exceed their **maximum value (overflow)** or go **below zero (underflow)**, the contract may break.\n\n#### ‚ùå Vulnerable Contract:\n```solidity\ncontract BadMath {\n    uint8 public num = 255; // Max value for uint8\n\n    function add() public {\n        num += 1; // Overflow! Resets to 0\n    }\n}\n```\n#### ‚úÖ Solution: Use SafeMath (or Solidity 0.8+, which has built-in checks)\n```solidity\nfunction add() public {\n    unchecked { num += 1; } // Use unchecked only if safe\n}\n```\nSolidity **0.8+ prevents overflows by default**, eliminating silent resets.\n\n### 3. SelfDestruct Function\nSome contracts include a `selfdestruct` function that, if **improperly secured**, allows **anyone to delete the contract permanently**.\n\n#### ‚ùå Vulnerable Contract:\n```solidity\ncontract BadContract {\n    function destroy() public {\n        selfdestruct(payable(msg.sender)); // Anyone can destroy the contract\n    }\n}\n```\n#### ‚úÖ Solution: Restrict `selfdestruct` to the Owner\n```solidity\ncontract SafeContract {\n    address private owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function destroy() public {\n        require(msg.sender == owner, "Not the owner!"); // Only owner can call\n        selfdestruct(payable(owner));\n    }\n}\n```\nThis ensures **only the contract owner** can delete it.\n\n### 4. Access Control Flaws\nIf functions **are not restricted**, anyone can call them and modify critical contract variables.\n\n#### ‚ùå Vulnerable Contract:\n```solidity\ncontract BadOwner {\n    address public owner;\n\n    function changeOwner(address newOwner) public {\n        owner = newOwner; // Anyone can take over the contract\n    }\n}\n```\n#### ‚úÖ Solution: Use an `onlyOwner` Modifier\n```solidity\ncontract SafeOwner {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, "Not the owner!");\n        _;\n    }\n\n    function changeOwner(address newOwner) public onlyOwner {\n        owner = newOwner; // Only owner can update\n    }\n}\n```\nThis ensures **only the original owner** can change ownership.\n\n## Best Practices for Secure Smart Contracts\n‚úÖ Use `onlyOwner` or `require(msg.sender == owner)` for critical functions.\n‚úÖ Always update balances **before making external calls** to prevent **reentrancy attacks**.\n‚úÖ Use Solidity **0.8+ to avoid integer overflows**.\n‚úÖ Emit **events** for important actions such as transfers and contract changes.\n‚úÖ **Never expose** `selfdestruct` unless absolutely necessary.\n\n## Summary & Hands-on Practice\nToday, we covered:\n- **Events** ‚Äì Solidity‚Äôs way of sending notifications.\n- **Reentrancy Attacks** ‚Äì How to prevent funds from being drained.\n- **Integer Overflow/Underflow** ‚Äì Avoiding silent math errors.\n- **SelfDestruct & Access Control** ‚Äì Protecting contracts from unauthorized access.\n\n### üî• Challenges:\n1Ô∏è‚É£ Create a contract where users can buy tokens, **emitting an event** each time.\n2Ô∏è‚É£ Implement a **secure withdrawal function** that prevents **reentrancy**.\n3Ô∏è‚É£ Build a **vault contract** with `onlyOwner` to change security settings.\n\n## üöÄ Up Next: Solidity Inheritance & Smart Contract Structuring\nIn the next lesson, we will learn how **smart contracts inherit** from each other, similar to **parent-child relationships** in code.\n\n**Keep coding and continue making Solidity contracts more secure!**',
      },
      {
        id: "inheritance-advanced-concepts",
        title: "Inheritance & Advanced Concepts",
        content:
          '# Lesson 7: Inheritance & Advanced Concepts\n\nWelcome back, Solidity explorer! Today, we‚Äôre diving into **inheritance** (letting contracts share features), **interfaces & abstract contracts** (setting rules for others to follow), and an **introduction to the ERC-20 & ERC-721 token standards**.\n\n---\n\n### 1. Inheritance in Solidity: Like Parents & Children\nThink of Solidity inheritance like a family tree:\n- **Parent contracts (base contracts)** define general functions.\n- **Child contracts (derived contracts)** inherit those functions and can add or modify them.\n\n#### Example: Basic Inheritance\n```solidity\n// Parent Contract (Base Contract)\ncontract Animal {\n    string public species;\n\n    function setSpecies(string memory _species) public {\n        species = _species;\n    }\n}\n\n// Child Contract (Derived Contract)\ncontract Dog is Animal {\n    string public name;\n\n    function setName(string memory _name) public {\n        name = _name;\n    }\n}\n```\n**Explanation:**\n- `Dog` inherits all properties of `Animal`.\n- `Dog` can still add `setName()` (specific to Dog).\n\n#### Overriding Functions (Modifying Parent Behavior)\n```solidity\ncontract Animal {\n    function makeSound() public pure virtual returns (string memory) {\n        return "Some generic animal sound";\n    }\n}\n\ncontract Dog is Animal {\n    function makeSound() public pure override returns (string memory) {\n        return "Woof! Woof!";\n    }\n}\n```\n**Explanation:**\n- The `virtual` keyword in `Animal` allows overriding.\n- The `override` keyword in `Dog` changes the function‚Äôs behavior.\n\n---\n\n### 2. Interfaces & Abstract Contracts\nInterfaces and abstract contracts define rules for how other contracts should behave.\n\n#### **Interfaces: Must-Implement Rules**\n```solidity\ninterface Vehicle {\n    function start() external;\n    function stop() external;\n}\n\ncontract Car is Vehicle {\n    function start() external override {\n        // Code to start the car\n    }\n    function stop() external override {\n        // Code to stop the car\n    }\n}\n```\n**Explanation:**\n- `Vehicle` is an interface‚Äîany contract using it **must** implement `start()` and `stop()`.\n- `Car` follows the blueprint, ensuring every car has a way to start and stop.\n\n#### **Abstract Contracts: Partially Built Houses**\n```solidity\nabstract contract Bank {\n    function deposit() public virtual;\n    function withdraw() public virtual;\n}\n\ncontract MyBank is Bank {\n    function deposit() public override {\n        // Code for depositing money\n    }\n    function withdraw() public override {\n        // Code for withdrawing money\n    }\n}\n```\n**Explanation:**\n- `Bank` is abstract, meaning **it cannot be deployed alone**.\n- `MyBank` completes it by defining `deposit()` and `withdraw()`.\n\n---\n\n### 3. Working with ERC-20 & ERC-721 Standards\nSolidity has established standards for tokens, making them easy to integrate across platforms.\n\n#### **ERC-20: Fungible tokens** (identical & interchangeable, like USD or Bitcoin)\n##### Basic ERC-20 functions:\n- `totalSupply()` ‚Üí Total tokens in existence\n- `balanceOf()` ‚Üí Check token balance of an address\n- `transfer()` ‚Üí Move tokens between users\n\n```solidity\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address account) external view returns (uint);\n    function transfer(address recipient, uint amount) external returns (bool);\n}\n```\n**Every ERC-20 token must follow this standard.**\n\n#### **ERC-721: NFTs (Unique Digital Assets)**\n##### Basic ERC-721 functions:\n- `ownerOf(tokenId)` ‚Üí Who owns this NFT?\n- `transferFrom()` ‚Üí Move the NFT to someone else\n- `mint()` ‚Üí Create a new NFT\n\n```solidity\ninterface IERC721 {\n    function ownerOf(uint tokenId) external view returns (address);\n    function transferFrom(address from, address to, uint tokenId) external;\n}\n```\n**Every NFT contract must include these functions.**\n\n---\n\n## Course Wrap-Up\nüéâ **Congratulations!** You now understand Solidity basics and can write smart contracts.\n\n### **Key Takeaways from the Course**\n‚úÖ Solidity syntax & smart contract structure  \n‚úÖ Variables, functions, and control structures  \n‚úÖ Mappings, structs, and arrays  \n‚úÖ Events & smart contract security  \n‚úÖ Inheritance, interfaces, and ERC-20/ERC-721  \n\n### **Next Steps & Practice Challenges**\nüîπ **Build a bank contract** that inherits from a base contract.  \nüîπ **Create a simple ERC-20 token** with transfer functionality.  \nüîπ **Make an NFT contract** that mints unique digital collectibles.  \n\nüìå **In the next course, we‚Äôll dive into deploying contracts on a real blockchain.**  \nKeep learning, keep building, and **welcome to the world of Web3!** üöÄ\n',
      },
    ],
  },
  {
    id: "intro-to-blockchain",
    title: "Introduction to Blockchain Technology",
    description:
      "Learn the core concepts of blockchain technology to build a solid foundation for developing decentralized applications.",
    level: "Beginner" as "Beginner",
    duration: "3 weeks",
    lessonCount: 5,
    tags: ["blockchain", "web3", "crypto", "decentralization"],
    registrations: 0,
    image: "/images/blockchain-intro.png",
    lessons: [
      {
        id: "blockchain-fundamentals",
        title: "Blockchain Fundamentals: The Digital Ledger",
        content:
          "# Lesson 1: Blockchain Fundamentals: The Digital Ledger\n\nHey there, future blockchain innovator! Welcome to the exciting world of blockchain technology. If you've ever wondered, \"What exactly is a blockchain, and why is everyone talking about it?\"‚Äîyou're in the right place. Let's break it down without any complex jargon and have some fun along the way.\n\n---\n\n## What is a Blockchain?\n\nImagine you and your friends keep a shared notebook. Every time someone makes a transaction (like \"Alice gives Bob $10\"), you write it down on a new page. But here's the twist:\n\n1. Everyone gets an identical copy of the notebook\n2. Each new page contains a special code linking it to the previous page\n3. If someone tries to change an old entry, everyone else will notice\n4. No single person controls the notebook‚Äîit's managed by everyone together\n\nThat's essentially what a blockchain is‚Äîa shared, tamper-proof digital ledger that records transactions across many computers.\n\n---\n\n## How Blocks Form a Chain\n\nA blockchain consists of connected \"blocks\" of data:\n\n```\nBlock #1 ‚Üí Block #2 ‚Üí Block #3 ‚Üí ...\n```\n\nEach block contains:\n- A batch of valid transactions\n- A timestamp\n- A reference to the previous block (called a \"hash\")\n- Its own unique identifier (also a hash)\n\nThis creates a chain where changing any single block would break the entire chain‚Äîmaking the system highly secure against tampering.\n\n---\n\n## The Three Pillars of Blockchain\n\n### 1. Decentralization\n\nTraditional systems (like banks) have a central authority. Blockchain spreads control across a network of computers (nodes).\n\n**Traditional Bank** vs. **Blockchain**\n```\nTraditional: You ‚Üí Bank (Central Authority) ‚Üí Transaction Processed\nBlockchain: You ‚Üí Network of Computers ‚Üí Transaction Processed\n```\n\n### 2. Transparency\n\nAll transactions are visible to everyone on the network, creating unprecedented transparency. Don't worry though‚Äîparticipants are identified by cryptographic addresses, not personal details!\n\n### 3. Immutability\n\nOnce data is recorded and confirmed, it becomes practically impossible to change or delete. This creates a permanent, unalterable history.\n\n---\n\n## Types of Blockchains\n\n### Public Blockchains\n‚úÖ Anyone can join and participate (like Bitcoin)\n‚úÖ Completely transparent and decentralized\n‚úÖ No central authority controls it\n\n### Private Blockchains\n‚úÖ Restricted to authorized participants\n‚úÖ Ideal for businesses and organizations\n‚úÖ Faster and more efficient than public blockchains\n\n### Hybrid/Consortium Blockchains\n‚úÖ Partly private, partly public\n‚úÖ Controlled by a group of organizations\n‚úÖ Combines benefits of both public and private chains\n\n---\n\n## Real-World Blockchain Use Cases\n\nBlockchain isn't just for cryptocurrencies! Here are some exciting applications:\n\n1. **Supply Chain Tracking** ‚Äì Follow products from manufacturer to consumer\n2. **Digital Identity** ‚Äì Own and control your personal data\n3. **Voting Systems** ‚Äì Secure, transparent elections\n4. **Healthcare Records** ‚Äì Secure, accessible medical history\n5. **Royalty Tracking** ‚Äì Ensure creators get paid fairly\n\n---\n\n## Wrap-Up & What's Next\n\nYou now understand what blockchain is‚Äîa decentralized, transparent, and immutable ledger technology. In the next lesson, we'll explore how consensus mechanisms keep these systems secure and functioning.\n\nThink about this: How might blockchain change your industry or daily life in the next five years?\n\nSee you in Lesson 2, where we'll dive into consensus mechanisms and cryptography! üöÄ",
      },
      {
        id: "consensus-cryptography",
        title: "Consensus Mechanisms & Cryptography",
        content:
          '# Lesson 2: Consensus Mechanisms & Cryptography\n\nWelcome back, blockchain explorer! üîç\n\nIn our last lesson, we learned that blockchain is a shared, tamper-proof ledger. But this raises an important question: Without a central authority, how does everyone agree on what transactions are valid? That\'s where consensus mechanisms and cryptography come in‚Äîthe secret sauce that makes blockchain work!\n\n---\n\n## The Byzantine Generals Problem\n\nBefore diving into consensus mechanisms, let\'s understand the problem they solve with a classic thought experiment.\n\nImagine several Byzantine generals surrounding an enemy city. They must decide together: attack or retreat. The catch? There might be traitors among them trying to sabotage their plan. How can the loyal generals reach agreement?\n\nThis is exactly the problem blockchain networks solve‚Äîhow to reach agreement in a network where some participants might be dishonest or unreliable.\n\n---\n\n## Consensus Mechanisms: How Blockchains Reach Agreement\n\nConsensus mechanisms are the rules that allow a decentralized network to agree on the state of the blockchain. Let\'s explore the most important ones:\n\n### 1. Proof of Work (PoW)\n\n**How it works:** Participants (miners) compete to solve complex mathematical puzzles. The first to solve it gets to add the next block and receives a reward.\n\n**Used by:** Bitcoin, Litecoin, Dogecoin\n\n**Pros:**\n- Proven security over many years\n- Highly decentralized\n\n**Cons:**\n- Energy intensive (Bitcoin uses as much electricity as some countries!)\n- Slower transaction processing\n\n### 2. Proof of Stake (PoS)\n\n**How it works:** Instead of solving puzzles, validators are selected to create blocks based on how many coins they "stake" (lock up as collateral). The more you stake, the more likely you are to be chosen.\n\n**Used by:** Ethereum (after "The Merge"), Cardano, Solana\n\n**Pros:**\n- Energy efficient (99.95% less energy than PoW)\n- Faster transactions\n- Economic penalties for bad behavior\n\n**Cons:**\n- Potentially less decentralized (the rich get richer)\n- More complex security considerations\n\n### 3. Delegated Proof of Stake (DPoS)\n\n**How it works:** Token holders vote for a small number of delegates who validate transactions and create blocks.\n\n**Used by:** EOS, Tron\n\n**Pros:**\n- Very fast transactions\n- Energy efficient\n\n**Cons:**\n- More centralized than other mechanisms\n\n### 4. Proof of Authority (PoA)\n\n**How it works:** Only approved validators (based on reputation) can validate transactions.\n\n**Used by:** Many private blockchains and sidechains\n\n**Pros:**\n- Highly efficient and fast\n- No mining required\n\n**Cons:**\n- Centralized by design\n\n---\n\n## Cryptography: The Magic Behind Blockchain\n\nCryptography provides the security foundation for blockchains. Here are the key concepts:\n\n### 1. Hash Functions\n\nA hash function is like a digital fingerprint‚Äîit takes any input and creates a fixed-size output that uniquely identifies the original data.\n\n**Example:**\n```\nInput: "Hello, Blockchain!"\nOutput (SHA-256): "33f70f86c42ee186b3f387b9c2f465936cb5ee4986e221f4c5723bb7a20e9b53"\n```\n\nChange just one character, and the output changes completely! This property helps ensure blockchain integrity.\n\n### 2. Public-Private Key Pairs\n\nThink of these as a magical mailbox:\n- The **public key** is like your mailbox address (everyone can see it)\n- The **private key** is like your mailbox key (only you have it)\n\n**How it works:**\n- Your public key generates your blockchain address\n- Your private key allows you to "sign" transactions\n- Others can verify your signature using your public key, without seeing your private key\n\n### 3. Digital Signatures\n\nDigital signatures prove you authorized a transaction without revealing your private key.\n\n**The process:**\n1. You create a transaction ("Send 1 BTC to Alice")\n2. You sign it with your private key\n3. The network verifies the signature using your public key\n4. If valid, the transaction is processed\n\n---\n\n## Putting It All Together: A Transaction Journey\n\nLet\'s follow a transaction through a blockchain network:\n\n1. **Creation**: Bob wants to send 1 ETH to Alice\n2. **Signing**: Bob signs the transaction with his private key\n3. **Broadcasting**: The signed transaction is broadcast to the network\n4. **Verification**: Nodes verify Bob\'s signature and check he has sufficient funds\n5. **Consensus**: Miners/validators include the transaction in a new block through the consensus mechanism\n6. **Confirmation**: The block is added to the chain, and Alice receives her 1 ETH\n7. **Immutability**: With each new block added, changing Bob\'s transaction becomes exponentially harder\n\n---\n\n## Try It Yourself: A Hashing Exercise\n\nLet\'s see hash functions in action:\n\n1. Go to an online SHA-256 hash generator\n2. Type "blockchain"\n3. See the resulting hash\n4. Now change one letter (e.g., "Blockchain") and see how different the hash becomes!\n\nThis simple exercise demonstrates how hash functions help detect even tiny changes in blockchain data.\n\n---\n\n## What\'s Next?\n\nIn Lesson 3, we\'ll explore the different types of blockchain platforms (like Bitcoin, Ethereum, and others) and what makes each unique.\n\n**Question to ponder:** How might different consensus mechanisms be better suited for different applications? Why might a voting system need a different mechanism than a cryptocurrency?\n\nSee you in the next lesson! üöÄ',
      },
      {
        id: "blockchain-platforms",
        title: "Blockchain Platforms & Smart Contracts",
        content:
          "# Lesson 3: Blockchain Platforms & Smart Contracts\n\nWelcome back, blockchain explorer! üöÄ\n\nSo far, we've learned what blockchain is and how it stays secure through consensus and cryptography. Now let's explore the major blockchain platforms and dive into the revolutionary concept of smart contracts!\n\n---\n\n## Major Blockchain Platforms\n\nThink of blockchain platforms as different operating systems (like Windows vs. macOS vs. Linux)‚Äîeach with its own strengths, weaknesses, and ideal use cases.\n\n### 1. Bitcoin (BTC)\n\n**Founded**: 2009 by Satoshi Nakamoto (pseudonym)\n\n**Primary Purpose**: Digital currency (\"digital gold\")\n\n**Key Features**:\n- First ever blockchain\n- Proof of Work consensus\n- Limited programmability (intentionally)\n- Highly secure and decentralized\n- Fixed supply (21 million BTC maximum)\n\n**Best For**: Store of value, payments, wealth preservation\n\n### 2. Ethereum (ETH)\n\n**Founded**: 2015 by Vitalik Buterin and team\n\n**Primary Purpose**: Smart contract platform (\"world computer\")\n\n**Key Features**:\n- First programmable blockchain\n- Transitioned from Proof of Work to Proof of Stake in 2022\n- Supports thousands of tokens and applications\n- Highly flexible but can be expensive during high demand\n\n**Best For**: DeFi, NFTs, DAOs, complex applications\n\n### 3. Solana (SOL)\n\n**Founded**: 2020 by Anatoly Yakovenko\n\n**Primary Purpose**: High-performance smart contract platform\n\n**Key Features**:\n- Extremely fast (thousands of TPS)\n- Low transaction costs (fractions of a penny)\n- Proof of Stake with Proof of History\n- Growing ecosystem of applications\n\n**Best For**: Applications needing high speed and low costs\n\n### 4. Polkadot (DOT)\n\n**Founded**: 2020 by Gavin Wood (Ethereum co-founder)\n\n**Primary Purpose**: Interoperability between blockchains\n\n**Key Features**:\n- Connects different blockchains together\n- Allows custom blockchains (parachains)\n- Shared security model\n- Nominated Proof of Stake\n\n**Best For**: Projects needing customizable blockchains with interoperability\n\n### 5. Binance Smart Chain (BSC)\n\n**Founded**: 2020 by Binance\n\n**Primary Purpose**: Smart contract platform with lower fees\n\n**Key Features**:\n- EVM compatible (can run Ethereum applications)\n- Proof of Staked Authority consensus\n- Fast block times (3 seconds)\n- Connected to Binance ecosystem\n\n**Best For**: Lower cost alternatives to Ethereum applications\n\n---\n\n## Smart Contracts: Self-Executing Agreements\n\nNow for the real game-changer: smart contracts!\n\n### What Are Smart Contracts?\n\nSmart contracts are self-executing programs stored on a blockchain that run automatically when predetermined conditions are met. They're like vending machines for agreements:\n\n1. Input conditions are met (insert money)\n2. Output is delivered automatically (get a soda)\n3. No third party is needed to enforce the rules\n\n### Example: A Simple Escrow Smart Contract\n\nLet's break down how an escrow smart contract works:\n\n```\nBuyer sends 10 ETH ‚Üí Smart Contract holds funds ‚Üí Seller delivers product ‚Üí Smart Contract verifies delivery ‚Üí Funds released to seller\n```\n\nNo bank or escrow service needed!\n\n### Key Benefits of Smart Contracts\n\n**1. Automation**  \nExecute automatically when conditions are met\n\n**2. Trustless**  \nDon't need to trust the other party\n\n**3. Immutable**  \nCan't be changed once deployed\n\n**4. Transparent**  \nRules visible to all parties\n\n**5. Cost-effective**  \nEliminate middlemen and reduce costs\n\n### Languages for Writing Smart Contracts\n\n**Solidity**: The most popular language (primarily for Ethereum and EVM-compatible chains)\n\n**Rust**: Used for Solana and some other platforms\n\n**Move**: Used in the Diem ecosystem\n\n**Vyper**: Python-like alternative for Ethereum\n\n### Smart Contract Limitations\n\n**1. Code is Law**  \nIf there's a bug in the code, it can lead to losses (like the DAO hack)\n\n**2. Oracle Problem**  \nSmart contracts can't access off-chain data directly\n\n**3. Immutability**  \nCan't easily fix bugs once deployed\n\n**4. Gas Costs**  \nMore complex contracts cost more to execute\n\n---\n\n## Real-World Applications of Smart Contracts\n\n### 1. Decentralized Finance (DeFi)\n\n**Examples**: Lending platforms, decentralized exchanges, yield farming\n\n**How it works**: Smart contracts automatically execute loans, trades, and interest payments without banks\n\n### 2. Non-Fungible Tokens (NFTs)\n\n**Examples**: Digital art, collectibles, virtual real estate\n\n**How it works**: Smart contracts prove ownership and manage royalties for creators\n\n### 3. Decentralized Autonomous Organizations (DAOs)\n\n**Examples**: Investment groups, charities, governance systems\n\n**How it works**: Organizations run by code instead of executives, with voting and treasury management\n\n### 4. Supply Chain Tracking\n\n**Examples**: Product authenticity, ethical sourcing verification\n\n**How it works**: Smart contracts record and verify each step in a product's journey\n\n---\n\n## Real Example: Simple Token Sale Contract\n\nHere's what a basic token sale contract might look like in Solidity:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract TokenSale {\n    address public owner;\n    uint256 public tokenPrice = 0.01 ether;\n    mapping(address => uint256) public tokenBalance;\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    function buyTokens() public payable {\n        uint256 numberOfTokens = msg.value / tokenPrice;\n        tokenBalance[msg.sender] += numberOfTokens;\n    }\n    \n    function transferTokens(address to, uint256 amount) public {\n        require(tokenBalance[msg.sender] >= amount, \"Not enough tokens\");\n        tokenBalance[msg.sender] -= amount;\n        tokenBalance[to] += amount;\n    }\n}\n```\n\nThis simple contract:\n1. Lets anyone buy tokens by sending ETH\n2. Tracks everyone's token balance\n3. Allows people to transfer tokens to others\n\n---\n\n## What's Next?\n\nIn Lesson 4, we'll explore decentralized applications (dApps) and how they're built on blockchain platforms.\n\n**Question to ponder**: What current business processes in your industry could be improved with smart contracts?\n\nSee you in the next lesson! üöÄ",
      },
      {
        id: "dapps-wallets",
        title: "Decentralized Applications (dApps) & Wallets",
        content:
          "# Lesson 4: Decentralized Applications (dApps) & Wallets\n\nWelcome back, blockchain explorer! üß≠\n\nNow that we understand blockchain platforms and smart contracts, let's see how they come together to create decentralized applications (dApps) and how users interact with them using wallets.\n\n---\n\n## What Are Decentralized Applications (dApps)?\n\nDecentralized applications (dApps) are digital applications that run on a blockchain network rather than a single computer. Think of them as the apps on your phone, but instead of running on Apple or Google's servers, they run on a decentralized network.\n\n### dApps vs. Traditional Apps\n\n| Feature | Traditional App | dApp |\n|---------|----------------|------|\n| Backend | Centralized servers | Blockchain network |\n| Downtime | Possible if servers fail | Very unlikely (network is distributed) |\n| Censorship | Can be shut down by authorities | Resistant to censorship |\n| Data control | Owned by the company | Owned by users |\n| Revenue model | Typically ad-based or subscription | Often token-based |\n\n### The Architecture of a dApp\n\nMost dApps have three main components:\n\n1. **Smart Contracts**: The backend logic on the blockchain\n2. **Frontend Interface**: What users see and interact with (website/mobile app)\n3. **External Data**: Often accessed through oracles (blockchain data feeds)\n\n```\nUser ‚Üí Frontend Interface ‚Üí Smart Contracts on Blockchain ‚Üí (Optional) External Data via Oracles\n```\n\n---\n\n## Popular Types of dApps\n\n### 1. DeFi (Decentralized Finance) Applications\n\n**Examples**: Uniswap, Aave, Compound\n\n**Function**: Financial services without intermediaries\n- Decentralized exchanges\n- Lending and borrowing\n- Yield farming\n- Stablecoins\n\n### 2. NFT Marketplaces\n\n**Examples**: OpenSea, Rarible, Foundation\n\n**Function**: Create, buy, sell, and trade unique digital assets\n\n### 3. DAOs (Decentralized Autonomous Organizations)\n\n**Examples**: MakerDAO, Gitcoin, Aragon\n\n**Function**: Community-governed organizations where decisions are made through voting\n\n### 4. Social Media dApps\n\n**Examples**: Lens Protocol, Mirror, Farcaster\n\n**Function**: Social networks where users own their data and content\n\n### 5. Gaming and Metaverse\n\n**Examples**: Axie Infinity, Decentraland, The Sandbox\n\n**Function**: Games with player-owned assets and economies\n\n---\n\n## Wallets: Your Gateway to Blockchain\n\nWallets are applications that allow users to interact with blockchain networks. Despite the name, they don't actually store your crypto‚Äîthey store the private keys that give you access to your blockchain assets.\n\n### Types of Wallets\n\n#### 1. Hot Wallets (Connected to the internet)\n\n**Browser Extensions**  \n- Examples: MetaMask, Phantom\n- Pros: Convenient for daily use\n- Cons: More vulnerable to hacking\n\n**Mobile Wallets**  \n- Examples: Trust Wallet, Coinbase Wallet\n- Pros: Accessible on the go\n- Cons: Phone can be lost or compromised\n\n**Web Wallets**  \n- Examples: Rainbow, Frame\n- Pros: No downloads needed\n- Cons: Dependent on the service provider\n\n#### 2. Cold Wallets (Offline storage)\n\n**Hardware Wallets**  \n- Examples: Ledger, Trezor\n- Pros: Very secure, offline storage\n- Cons: Cost money, less convenient\n\n**Paper Wallets**  \n- Literally printing keys on paper\n- Pros: Completely offline\n- Cons: Can be lost, damaged, or stolen\n\n### How Wallets Work\n\n1. **Create/Import**: Generate new keys or import existing ones\n2. **Store**: Securely store your private keys\n3. **View**: Check your balances and transaction history\n4. **Sign**: Authorize transactions with your private key\n5. **Connect**: Interact with dApps by connecting your wallet\n\n### Seed Phrases: The Master Key\n\nMost wallets use a seed phrase (or recovery phrase)‚Äîtypically 12 or 24 random words that can recover all your private keys.\n\n**Example**: `witch collapse practice feed shame open despair creek road again ice least`\n\n‚ö†Ô∏è **Critical Warning**: Never share your seed phrase with anyone! Whoever has your seed phrase has complete control over all your crypto assets.\n\n---\n\n## How Users Interact with dApps\n\nLet's walk through a typical user journey with a dApp:\n\n1. **Install a wallet** (like MetaMask)\n2. **Fund your wallet** with the appropriate cryptocurrency\n3. **Visit the dApp website**\n4. **Connect your wallet** to the dApp\n5. **Approve permissions** (what the dApp can access)\n6. **Use the dApp** (make trades, buy NFTs, vote in a DAO, etc.)\n7. **Sign transactions** when prompted\n8. **Pay gas fees** for blockchain operations\n\n### Example: Trading on a Decentralized Exchange\n\n```\nUser installs MetaMask ‚Üí Buys ETH ‚Üí Visits Uniswap ‚Üí Connects wallet ‚Üí \nSelects tokens to swap ‚Üí Approves token access ‚Üí Confirms transaction ‚Üí \nPays gas fee ‚Üí Receives new tokens in wallet\n```\n\n---\n\n## The Developer Perspective\n\nAs a developer building dApps, you'll typically need:\n\n1. **Smart Contract Development**\n   - Write and test smart contracts (Solidity, Rust, etc.)\n   - Deploy contracts to testnet, then mainnet\n\n2. **Frontend Development**\n   - Build user interface (React, Vue, etc.)\n   - Integrate with wallet providers (Web3.js, ethers.js, etc.)\n\n3. **Testing and Security**\n   - Smart contract audits\n   - Frontend security testing\n\n4. **Deployment and Maintenance**\n   - Host frontend on web servers or IPFS (decentralized storage)\n   - Monitor contract performance\n\n---\n\n## Try It Yourself: Your First dApp Interaction\n\nReady to try a dApp? Here's a simple way to start:\n\n1. Install MetaMask browser extension\n2. Get some test ETH from a faucet (for Ethereum testnet)\n3. Visit a simple dApp like a testnet NFT minter\n4. Connect your wallet and mint a test NFT\n\nThis hands-on experience will help you understand how the user-dApp interaction flows!\n\n---\n\n## What's Next?\n\nIn our final lesson, we'll explore the challenges in blockchain development and the future of Web3. We'll also look at how to start your journey as a blockchain developer.\n\n**Question to ponder**: What kind of dApp would you build to solve a problem in your field of interest?\n\nSee you in the final lesson! üöÄ",
      },
      {
        id: "blockchain-future",
        title: "Blockchain Development Challenges & The Future of Web3",
        content:
          "# Lesson 5: Blockchain Development Challenges & The Future of Web3\n\nWelcome to our final lesson, blockchain pioneer! üöÄ\n\nWe've covered the essentials of blockchain technology, smart contracts, and decentralized applications. Now let's explore the challenges you'll face as a blockchain developer, where the industry is heading, and how to start your journey into this exciting field.\n\n---\n\n## Blockchain Development Challenges\n\nDeveloping for blockchain comes with unique challenges that differ from traditional software development.\n\n### 1. Immutability: Code That Can't Be Changed\n\nChallenge: Once deployed, smart contracts generally can't be modified.\n\nImpact: A single bug could lock funds forever or create security vulnerabilities.\n\nSolution: Thorough testing, code audits, and upgradeable contract patterns.\n\n### 2. Gas Costs: Every Operation Has a Price\n\nChallenge: Each operation in your smart contract costs gas (transaction fees).\n\nImpact: Inefficient code can make your dApp too expensive for users.\n\nSolution: Gas optimization techniques, like minimizing storage operations and batching transactions.\n\n### 3. Limited Storage: Blockchain Isn't a Database\n\nChallenge: Storing data on-chain is extremely expensive.\n\nImpact: You can't use blockchain like a traditional database.\n\nSolution: Store only critical data on-chain; use off-chain storage (IPFS, Arweave) for larger data.\n\n### 4. Oracle Problem: Getting External Data\n\nChallenge: Smart contracts can't access off-chain data directly.\n\nImpact: Any dApp that needs real-world data faces trust issues.\n\nSolution: Decentralized oracle networks like Chainlink.\n\n### 5. User Experience: The Adoption Challenge\n\nChallenge: Blockchain UX is often complex for average users.\n\nImpact: Limited mainstream adoption.\n\nSolution: Abstract complexity, social recovery, better onboarding flows.\n\n---\n\n## The Evolution of Web: 1.0 to 3.0\n\nTo understand where we're going, let's look at how the web has evolved:\n\n### Web 1.0 (1990-2005): Read-Only Web\n- Static websites\n- One-way information flow\n- Users consume content\n\n### Web 2.0 (2005-2020): Read-Write Web\n- Social media, user-generated content\n- Centralized platforms (Facebook, Google, Amazon)\n- Users create content but don't own it\n- Data as the product (\"If it's free, you're the product\")\n\n### Web 3.0 (Emerging): Read-Write-Own Web\n- Decentralized applications\n- User ownership of data and digital assets\n- Trustless interactions via smart contracts\n- Token-based economies\n\n---\n\n## The Future of Web3 & Blockchain\n\nHere are some key trends that will shape the future of blockchain technology:\n\n### 1. Layer 2 Scaling Solutions\n\nWhat it is: Technologies built on top of existing blockchains to improve scalability.\n\nExamples: \n- Ethereum: Optimistic Rollups, ZK-Rollups (like Arbitrum, Optimism, zkSync)\n- Bitcoin: Lightning Network\n\nImpact: Faster, cheaper transactions while maintaining security.\n\n### 2. Cross-Chain Interoperability\n\nWhat it is: Different blockchains communicating and sharing data/value.\n\nExamples: Polkadot, Cosmos, Chainlink CCIP\n\nImpact: A connected ecosystem rather than isolated blockchain \"islands\".\n\n### 3. Real-World Asset Tokenization\n\nWhat it is: Representing physical assets (real estate, art, commodities) on blockchain.\n\nImpact: Fractional ownership, 24/7 markets, global accessibility.\n\n### 4. Decentralized Identity\n\nWhat it is: Self-sovereign identity systems on blockchain.\n\nExamples: Ethereum Name Service (ENS), Civic, Soulbound Tokens\n\nImpact: Users control their identity and credentials without relying on central authorities.\n\n### 5. DePIN (Decentralized Physical Infrastructure Networks)\n\nWhat it is: Blockchain-based networks for physical infrastructure like computing, storage, and sensors.\n\nExamples: Helium, Filecoin, Render Network\n\nImpact: Democratized ownership of infrastructure with token incentives.\n\n---\n\n## Getting Started as a Blockchain Developer\n\nReady to dive deeper? Here's a roadmap to become a blockchain developer:\n\n### 1. Build Foundation Skills\n\nWeb Development Basics:\n- JavaScript, HTML, CSS\n- React or other frontend frameworks\n- Backend development concepts\n\nBlockchain Fundamentals:\n- Cryptography basics\n- Blockchain architecture\n- Consensus mechanisms\n\n### 2. Learn Smart Contract Development\n\nChoose Your Ecosystem:\n- Ethereum/EVM (Solidity)\n- Solana (Rust)\n- Other platforms based on your interest\n\nRecommended Resources:\n- CryptoZombies (interactive Solidity learning)\n- Ethereum.org developer docs\n- Buildspace.so (project-based learning)\n\n### 3. Build Your First Projects\n\nStart Small:\n- Simple token contract\n- Basic NFT implementation\n- Decentralized voting app\n\nLearn Development Tools:\n- Hardhat or Truffle (development environment)\n- ethers.js or web3.js (blockchain interaction)\n- OpenZeppelin (secure contract libraries)\n\n### 4. Dive Into Security\n\nStudy Common Vulnerabilities:\n- Reentrancy attacks\n- Front-running\n- Integer overflow/underflow\n\nResources:\n- Consensys Smart Contract Best Practices\n- Ethernaut (security challenges)\n- DeFi Security Fundamentals\n\n### 5. Join the Community\n\nFind Your Tribe:\n- GitHub repositories\n- Discord communities\n- Hackathons (ETHGlobal, Encode Club)\n- StackExchange for Ethereum\n\n---\n\n## Final Project Ideas\n\nHere are some project ideas to apply what you've learned:\n\n### Beginner Level\n- Token-Gated Website: Create a website with content only accessible to token holders\n- Simple DAO: Build a basic voting system for collective decisions\n- NFT Collection: Create and deploy your own NFT collection\n\n### Intermediate Level\n- DeFi Application: Build a simple lending protocol or token swap\n- DAO Treasury Management: Create a system for managing collective funds\n- Cross-Chain Bridge: Develop a simple bridge between two testnets\n\n### Advanced Level\n- Layer 2 Solution: Implement a scaling solution\n- Decentralized Identity System: Build a credential verification system\n- Oracle Implementation: Create a decentralized data feed\n\n---\n\n## Conclusion: Your Blockchain Journey\n\nCongratulations on completing this introduction to blockchain technology! You've learned:\n\n1. The fundamental concepts of blockchain\n2. How consensus mechanisms and cryptography secure networks\n3. Major blockchain platforms and smart contracts\n4. How decentralized applications and wallets work\n5. The challenges and future of blockchain development\n\nRemember, blockchain technology is still evolving rapidly. Stay curious, keep learning, and most importantly‚Äîbuild projects! The best way to understand blockchain is to create something with it.\n\nAs you continue your journey, remember that you're part of a revolution that's changing how we think about trust, ownership, and digital interaction. The skills you develop now will be invaluable as Web3 continues to grow.\n\nWhat will you build first? Your journey into blockchain development starts now!\n\nSee you in the decentralized future! üöÄ",
      },
    ],
  },
];
